package com.monkopedia.sdbus.header

import com.monkopedia.sdbus.internal.Unowned

/********************************************//**
 * @class ProxyObjectHolder
 *
 * ProxyObjectHolder is a helper that simply owns and provides
 * access to a proxy object to other classes in the inheritance
 * hierarchy of a native-like proxy object based on generated
 * interface classes.
 *
 ***********************************************/
open class ProxyObjectHolder protected constructor(val proxy: IProxy)

/********************************************//**
 * @class ProxyInterfaces
 *
 * ProxyInterfaces is a helper template class that joins all interface classes of a remote
 * D-Bus object generated by sdbus-c++-xml2cpp to be used on the client (the proxy) side,
 * including some auxiliary classes. ProxyInterfaces is the class that native-like proxy
 * implementation classes written by users should inherit from and implement all pure virtual
 * methods. So the _Interfaces template parameter is a list of sdbus-c++-xml2cpp-generated
 * proxy-side interface classes representing interfaces of the corresponding remote D-Bus object.
 *
 * In the final adaptor class inherited from ProxyInterfaces, one needs to make sure:
 *   1. to call `registerProxy();` in the class constructor, and, conversely,
 *   2. to call `unregisterProxy();` in the class destructor,
 * so that the signals are subscribed to and unsubscribed from at a proper time.
 *
 ***********************************************/
class ProxyInterfaces<T : ProxyInterfaces<T>>(proxy: IProxy) : ProxyObjectHolder(proxy) {

    /*!
     * @brief Registers handlers for D-Bus signals of the remote object
     *
     * This function must be called in the constructor of the final proxy class that implements ProxyInterfaces.
     *
     * See also @ref IProxy::registerSignalHandler()
     */
    fun registerProxy() {
//        (_Interfaces::registerProxy(), ...);
    }

    /*!
     * @brief Unregisters the proxy so it no more receives signals and async call replies
     *
     * This function must be called in the destructor of the final proxy class that implements ProxyInterfaces.
     *
     * See underlying @ref IProxy::unregister()
     */
    fun unregisterProxy() {
        proxy.unregister();
    }

    open class BaseCompanion<T : ProxyInterfaces<T>>(private val constructor: (IProxy) -> T) {
        /*!
         * @brief Creates native-like proxy object instance
         *
         * @param[in] destination Bus name that provides a D-Bus object
         * @param[in] objectPath Path of the D-Bus object
         *
         * This constructor overload creates a proxy that manages its own D-Bus connection(s).
         * For more information on its behavior, consult @ref createProxy(std::string,std::string)
         */
        operator fun invoke(destination: ServiceName , objectPath: ObjectPath): T
            = constructor(createProxy(destination, objectPath))

        /*!
         * @brief Creates native-like proxy object instance
         *
         * @param[in] destination Bus name that provides a D-Bus object
         * @param[in] objectPath Path of the D-Bus object
         *
         * This constructor overload creates a proxy that manages its own D-Bus connection(s).
         * For more information on its behavior, consult @ref createProxy(std::string,std::string,sdbus::dont_run_event_loop_thread_t)
         */
        operator fun invoke(destination: ServiceName, objectPath: ObjectPath, dont_run_event_loop_thread: dont_run_event_loop_thread_t): T
            = constructor(createProxy(destination, objectPath, dont_run_event_loop_thread))

        /*!
         * @brief Creates native-like proxy object instance
         *
         * @param[in] connection D-Bus connection to be used by the proxy object
         * @param[in] destination Bus name that provides a D-Bus object
         * @param[in] objectPath Path of the D-Bus object
         *
         * The proxy created this way just references a D-Bus connection owned and managed by the user.
         * For more information on its behavior, consult @ref createProxy(IConnection&,std::string,std::string)
         */
        operator fun invoke(connection: IConnection, destination: ServiceName, objectPath: ObjectPath): T
            = constructor(createProxy(connection, destination, objectPath))

        /*!
         * @brief Creates native-like proxy object instance
         *
         * @param[in] connection D-Bus connection to be used by the proxy object
         * @param[in] destination Bus name that provides a D-Bus object
         * @param[in] objectPath Path of the D-Bus object
         *
         * The proxy created this way becomes an owner of the connection.
         * For more information on its behavior, consult @ref createProxy(std::unique_ptr<sdbus::IConnection>&&,std::string,std::string,sdbus::dont_run_event_loop_thread_t)
         */
        operator fun invoke(connection: IConnection, destination: ServiceName, objectPath: ObjectPath, dont_run_event_loop_thread: dont_run_event_loop_thread_t): T
        = constructor(createProxy(connection, destination, objectPath, dont_run_event_loop_thread))

    }
};
